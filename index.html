<!doctype html>
<html lang="en">

<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>zksync-wtf — search</title>
  <style>
    :root {
      --bg: #0b0d12;
      --muted-bg: #11141b;
      --fg: #e9edf1;
      --fg-dim: #b8c0cc;
      --accent: #7cd2ff;
      --accent-2: #9d7cff;
      --border: #1c2230;
      --good: #40c463;
      --warn: #ffcc66;
      --radius: 14px;
      --shadow: 0 10px 30px rgba(0, 0, 0, 0.35);
    }

    @media (prefers-color-scheme: light) {
      :root {
        --bg: #f7f8fb;
        --muted-bg: #ffffff;
        --fg: #111418;
        --fg-dim: #384252;
        --accent: #2563eb;
        --accent-2: #7c3aed;
        --border: #e5e7eb;
        --shadow: 0 10px 30px rgba(0, 0, 0, 0.08);
      }
    }

    * {
      box-sizing: border-box
    }

    html,
    body {
      height: 100%
    }

    body {
      margin: 0;
      background: radial-gradient(1200px 800px at 20% -10%, rgba(124, 210, 255, 0.12), transparent),
        radial-gradient(1000px 600px at 120% 0%, rgba(157, 124, 255, 0.10), transparent),
        var(--bg);
      color: var(--fg);
      font: 16px/1.45 system-ui, -apple-system, Segoe UI, Roboto, Inter, "Helvetica Neue", Arial, "Apple Color Emoji", "Segoe UI Emoji";
      padding: 28px 18px 60px;
    }

    .wrap {
      max-width: 1100px;
      margin: 0 auto;
    }

    header {
      display: grid;
      gap: 12px;
      margin-bottom: 18px;
    }

    h1 {
      font-weight: 750;
      letter-spacing: -0.02em;
      margin: 0;
      font-size: clamp(22px, 4vw, 32px);
      display: flex;
      align-items: center;
      gap: 10px;
    }

    .tag {
      font-size: 12px;
      color: var(--fg-dim);
      border: 1px solid var(--border);
      padding: 2px 8px;
      border-radius: 999px;
      background: linear-gradient(180deg, rgba(255, 255, 255, 0.04), rgba(0, 0, 0, 0.04));
    }

    .searchbar {
      position: relative;
      display: flex;
      align-items: center;
      background: var(--muted-bg);
      border: 1px solid var(--border);
      border-radius: var(--radius);
      padding: 10px 14px;
      box-shadow: var(--shadow);
      gap: 10px;
    }

    .searchbar input {
      width: 100%;
      font: inherit;
      border: none;
      outline: none;
      background: transparent;
      color: var(--fg);
      padding: 8px 6px;
    }

    .kbd {
      font-size: 12px;
      color: var(--fg-dim);
      border: 1px solid var(--border);
      border-bottom-width: 2px;
      border-radius: 8px;
      padding: 2px 6px;
    }

    .hint {
      font-size: 13px;
      color: var(--fg-dim);
    }

    table {
      width: 100%;
      border-collapse: separate;
      border-spacing: 0;
      background: var(--muted-bg);
      border: 1px solid var(--border);
      border-radius: var(--radius);
      overflow: visible;
      box-shadow: var(--shadow);
      table-layout: fixed;
    }

    thead th {
      text-align: left;
      font-weight: 650;
      font-size: 13px;
      color: var(--fg-dim);
      padding: 12px 14px;
      border-bottom: 1px solid var(--border);
      background: linear-gradient(180deg, rgba(255, 255, 255, 0.02), rgba(0, 0, 0, 0.02));
    }

    tbody td {
      padding: 12px 14px;
      border-bottom: 1px solid var(--border);
      vertical-align: top;
      word-break: break-word;
    }

    tbody tr:last-child td {
      border-bottom: none;
    }

    .key {
      font-weight: 620;
      letter-spacing: -0.01em;
    }

    .value {
      color: var(--fg-dim);
      font-family: ui-monospace, SFMono-Regular, Menlo, Consolas, monospace;
      font-size: 13px;
    }

    .controls {
      gap: 8px;
      align-items: center;
      min-width: 0;
    }

    .linkbtn,
    .infobtn {
      appearance: none;
      border: 1px solid var(--border);
      background: linear-gradient(180deg, rgba(255, 255, 255, 0.04), rgba(0, 0, 0, 0.04));
      color: var(--fg);
      padding: 6px 10px;
      border-radius: 10px;
      text-decoration: none;
      font-size: 13px;
      display: inline-flex;
      align-items: center;
      gap: 6px;
      cursor: pointer;
    }

    .linkbtn:hover,
    .infobtn:hover {
      border-color: color-mix(in srgb, var(--accent) 50%, var(--border));
    }

    .linkbtn:focus-visible,
    .infobtn:focus-visible {
      outline: 2px solid var(--accent);
      outline-offset: 2px;
    }

    .linkbtn .dot {
      width: 6px;
      height: 6px;
      border-radius: 50%;
      background: var(--accent);
      display: inline-block;
    }

    mark {
      background: color-mix(in srgb, var(--accent) 25%, transparent);
      color: inherit;
      padding: 0 2px;
      border-radius: 4px;
    }

    .badge {
      font-size: 11px;
      padding: 2px 6px;
      border-radius: 999px;
      border: 1px solid var(--border);
      color: var(--fg-dim);
    }

    .score {
      min-width: 60px;
      text-align: right;
      font-variant-numeric: tabular-nums;
      color: var(--fg-dim);
    }

    /* Tooltip */
    .tooltip {
      position: relative;
    }

    .tooltip[data-tip]::after {
      content: attr(data-tip);
      position: absolute;
      inset: auto auto calc(100% + 8px) 0;
      min-width: 220px;
      max-width: min(520px, 70vw);
      background: var(--muted-bg);
      color: var(--fg);
      border: 1px solid var(--border);
      padding: 10px 12px;
      border-radius: 10px;
      opacity: 0;
      transform: translateY(6px);
      pointer-events: none;
      transition: .15s;
      box-shadow: var(--shadow);
      white-space: pre-wrap;
      z-index: 10;
    }

    .tooltip:hover::after,
    .tooltip:focus-within::after {
      opacity: 1;
      transform: translateY(0);
    }

    .empty {
      margin-top: 18px;
      color: var(--fg-dim);
      text-align: center;
    }

    .meta {
      display: flex;
      gap: 10px;
      align-items: center;
      justify-content: space-between;
      margin: 12px 2px 8px;
      color: var(--fg-dim);
      font-size: 12px;
    }
  </style>
</head>

<body>
  <div class="wrap">
    <header>

      <h1>zksync-wtf <span class="tag">search</span></h1>
      <div class="searchbar" role="search">
        <svg width="18" height="18" viewBox="0 0 24 24" aria-hidden="true">
          <path fill="currentColor"
            d="M15.5 14h-.79l-.28-.27A6.471 6.471 0 0 0 16 9.5 6.5 6.5 0 1 0 9.5 16a6.471 6.471 0 0 0 4.23-1.57l.27.28v.79l5 5 1.5-1.5-5-5zM4 9.5C4 6.46 6.46 4 9.5 4S15 6.46 15 9.5 12.54 15 9.5 15 4 12.54 4 9.5z" />
        </svg>
        <input id="q" type="text" placeholder="Search by key or value — try: 0xffb1… or ‘leaf hash’" aria-label="Search"
          autofocus />
        <span class="kbd" title="Press slash to focus">/</span>
      </div>
      <div class="hint">Type multiple words — search is fuzzy and incremental. Exact/prefix hits rank highest; typos are
        tolerated.</div>
    </header>

    <div class="meta"><span id="count"></span><span id="source"></span></div>

    <table role="table" aria-label="Search results">
      <thead>
        <tr>
          <th style="width: 28%">Key</th>
          <th>Value</th>
          <th style="width: 100px">Open</th>
          <th style="width: 120px">Info</th>
          <th style="width: 88px; text-align:right">Score</th>
        </tr>
      </thead>
      <tbody id="rows"></tbody>
    </table>

    <div class="empty" id="empty" hidden>Start typing to see results…</div>
  </div>

  <script>
    // ---- Data loading (embedded sample + ?data=URL support) -----------------
    const EMBED = {
      items: [
        {
          key: "0.24.0.leaf", value: "0xffb19d007c67b9000b40b372e7a7a55a47d11c92588515598d6cad4052c75ebb",
          description: "Boojum Hash for 0.24.0.leaf version 0.24.0 in zksync-era",
          url: "https://github.com/matter-labs/zksync-era/blob/main/prover/data/historical_data/0.24.0/commitments.json"
        },
        { key: "airbender:verifier params", value: "0x1234abcd…", description: "Verifier params hex in zksync-airbender", url: "https://github.com/matter-labs/zksync-airbender/" },
        { key: "bridgehub chain", value: "324", description: "ZKsync Era chain id", url: "https://chainlist.org/chain/324" }
      ]
    };

    //const qs = new URLSearchParams(location.search);
    const dataURL = "https://raw.githubusercontent.com/mm-zk/zksync-wtf/refs/heads/master/zksync_wtf_data.json";

    let DATA = EMBED.items;

    async function loadData() {
      if (!dataURL) {
        document.getElementById('source').textContent = "source: embedded sample";
        return;
      }
      try {
        const r = await fetch(dataURL, { cache: "no-store" });
        const json = await r.json();
        // Accept either {items:[...]} or [...] shape.
        DATA = Array.isArray(json) ? json : (json.items || json);
        document.getElementById('source').textContent = "source: " + new URL(dataURL, location.href).hostname;
      } catch (e) {
        console.error("Failed to load data:", e);
        document.getElementById('source').textContent = "source: error loading data";
      }
    }

    // ---- Fuzzy search utilities (word-wise, incremental) -------------------
    const isHexish = s => /^0x[0-9a-f]+$/i.test(s.trim());
    const norm = s => s.toLowerCase();
    const tokenize = s => norm(s).split(/[^a-z0-9]+/i).filter(Boolean);

    // Cheap subsequence check: returns density (0..1) or -1 if not subsequence.
    function subseqScore(q, t) {
      let qi = 0, ti = 0;
      while (qi < q.length && ti < t.length) {
        if (q[qi] === t[ti]) qi++;
        ti++;
      }
      if (qi < q.length) return -1;
      // Higher if packed tightly
      const span = ti;
      return Math.max(0.3, Math.min(1, q.length / span));
    }

    // Levenshtein distance (bounded): bail early if exceeding maxD.
    function editDistanceBound(a, b, maxD) {
      const la = a.length, lb = b.length;
      if (Math.abs(la - lb) > maxD) return maxD + 1;
      const dp = Array(lb + 1);
      for (let j = 0; j <= lb; j++) dp[j] = j;
      for (let i = 1; i <= la; i++) {
        let prev = dp[0]; // value from dp[i-1][j-1]
        dp[0] = i;
        let minRow = dp[0];
        for (let j = 1; j <= lb; j++) {
          const temp = dp[j];
          const cost = a[i - 1] === b[j - 1] ? 0 : 1;
          dp[j] = Math.min(
            dp[j] + 1,    // deletion
            dp[j - 1] + 1,// insertion
            prev + cost   // substitution
          );
          prev = temp;
          if (dp[j] < minRow) minRow = dp[j];
        }
        if (minRow > maxD) return maxD + 1; // early exit
      }
      return dp[lb];
    }

    // Score a single query token against a field string.
    // Returns {score, type, range:[start,end]} or null if no reasonable match.
    function scoreTokenAgainst(field, q) {
      const f = norm(field), qq = norm(q);
      if (!qq) return null;

      // Strong tiers
      if (f === qq) return { score: 100, type: "exact", range: [0, f.length] };

      // Word-token level checks
      const words = tokenize(field);
      // Prefix / word starts-with
      for (const w of words) {
        if (w.startsWith(qq)) {
          const i = f.indexOf(qq);
          return { score: 95 - Math.max(0, w.length - qq.length) * 0.5, type: "prefix", range: [i, i + qq.length] };
        }
      }
      // Substring anywhere
      const idx = f.indexOf(qq);
      if (idx !== -1) {
        return { score: 86 - Math.min(20, idx) * 0.3, type: "substr", range: [idx, idx + qq.length] };
      }

      // Subsequence (good for spaced hex, names)
      const sub = subseqScore(qq, f);
      if (sub >= 0) {
        return { score: 72 * sub, type: "subseq", range: null };
      }

      // Fuzzy edit distance against each word token (bounded by length)
      const maxD = qq.length >= 7 ? 2 : (qq.length >= 4 ? 1 : 0);
      if (maxD > 0) {
        let best = null;
        for (const w of words.length ? words : [f]) {
          const d = editDistanceBound(qq, w, maxD);
          if (d <= maxD) {
            const s = 68 - d * 8 + Math.min(10, Math.abs(w.length - qq.length) * -0.5);
            if (!best || s > best.score) {
              best = { score: s, type: "fuzzy", range: null };
            }
          }
        }
        if (best) return best;
      }
      return null;
    }

    // Aggregate score for an item across all query tokens.
    // Each token can match either key OR value; item must satisfy all tokens.
    function scoreItem(item, tokens) {
      if (!tokens.length) return null;
      let total = 0;
      let matchMeta = []; // per-token info for highlighting
      for (const t of tokens) {
        const ks = scoreTokenAgainst(item.key, t);
        const vs = scoreTokenAgainst(item.value ?? "", t);
        if (!ks && !vs) return null; // AND logic: must satisfy each token
        // Prefer the better of key/value; slight bias towards key.
        let pick, pickedField = "value";
        if (ks && vs) {
          const kscore = ks.score + 3; // bias key +3
          pick = kscore >= vs.score ? { ...ks, score: kscore } : vs;
          pickedField = kscore >= vs.score ? "key" : "value";
        } else {
          pick = ks ?? vs;
          pickedField = ks ? "key" : "value";
        }
        total += pick.score;
        matchMeta.push({ token: t, where: pickedField, info: pick });
      }

      // Tie-breakers: shorter value (e.g., exact address) and more exact/prefix hits
      const exactCount = matchMeta.filter(m => m.info.type === "exact").length;
      const strongCount = matchMeta.filter(m => m.info.type === "exact" || m.info.type === "prefix" || m.info.type === "substr").length;
      total += exactCount * 6 + strongCount * 2;
      return { score: total, meta: matchMeta };
    }

    // Highlight helper: mark substring ranges only (prefix/substring/exact).
    function highlight(text, ranges) {
      if (!ranges || !ranges.length) return escapeHtml(text);
      ranges.sort((a, b) => a[0] - b[0]);
      let out = "", i = 0;
      for (const [s, e] of ranges) {
        if (s == null || e == null || s < 0 || e <= s) continue;
        out += escapeHtml(text.slice(i, s));
        out += "<mark>" + escapeHtml(text.slice(s, e)) + "</mark>";
        i = e;
      }
      out += escapeHtml(text.slice(i));
      return out;
    }
    const esc = { "&": "&amp;", "<": "&lt;", ">": "&gt;", "\"": "&quot;", "'": "&#39;" };
    const escapeHtml = s => String(s).replace(/[&<>"']/g, m => esc[m]);

    // ---- UI wiring ----------------------------------------------------------
    const $q = document.getElementById('q');
    const $rows = document.getElementById('rows');
    const $empty = document.getElementById('empty');
    const $count = document.getElementById('count');

    function debounce(fn, ms = 80) { let t; return (...a) => { clearTimeout(t); t = setTimeout(() => fn(...a), ms); }; }

    function render(results, tokens) {
      $rows.innerHTML = "";
      if (!tokens.length) {
        $empty.hidden = false;
        $count.textContent = "";
        return;
      }
      $empty.hidden = true;
      const frag = document.createDocumentFragment();
      for (const r of results) {
        const item = r.item;
        // Collect highlight ranges per field from strong matches
        const keyRanges = r.details.filter(d => d.where === "key" && (d.info.type === "exact" || d.info.type === "prefix" || d.info.type === "substr"))
          .map(d => d.info.range).filter(Boolean);
        const valRanges = r.details.filter(d => d.where === "value" && (d.info.type === "exact" || d.info.type === "prefix" || d.info.type === "substr"))
          .map(d => d.info.range).filter(Boolean);

        const tr = document.createElement('tr');

        const tdKey = document.createElement('td');
        tdKey.className = "key";
        tdKey.innerHTML = highlight(item.key, keyRanges);
        tr.appendChild(tdKey);

        const tdVal = document.createElement('td');
        tdVal.className = "value";
        tdVal.innerHTML = highlight(item.value ?? "", valRanges);
        tr.appendChild(tdVal);

        const tdOpen = document.createElement('td');
        tdOpen.className = "controls";
        const a = document.createElement('a');
        a.className = "linkbtn";
        a.href = item.url || "#";
        a.target = "_blank";
        a.rel = "noopener";
        a.innerHTML = '<span class="dot" aria-hidden="true"></span>Open';
        tdOpen.appendChild(a);
        tr.appendChild(tdOpen);

        const tdInfo = document.createElement('td');
        tdInfo.className = "controls";
        const infoBtn = document.createElement('button');
        infoBtn.className = "infobtn tooltip";
        infoBtn.type = "button";
        infoBtn.setAttribute("data-tip", (item.description || "No description available").toString());
        infoBtn.innerHTML = "Info";
        tdInfo.appendChild(infoBtn);
        tr.appendChild(tdInfo);

        const tdScore = document.createElement('td');
        tdScore.className = "score";
        tdScore.textContent = Math.round(r.score).toString();
        tr.appendChild(tdScore);

        frag.appendChild(tr);
      }
      $rows.appendChild(frag);
      $count.textContent = results.length ? `${results.length} result${results.length > 1 ? "s" : ""}` : "No results";
    }

    function search(q) {
      const raw = q.trim();
      const tokens = raw.split(/\s+/).filter(Boolean);
      if (!tokens.length) { render([], tokens); return; }

      const out = [];
      for (const item of DATA) {
        const s = scoreItem(item, tokens);
        if (!s) continue;
        out.push({
          item,
          score: s.score,
          details: s.meta
        });
      }
      out.sort((a, b) => b.score - a.score
        || (a.item.key.length - b.item.key.length) // shorter key first
        || String(a.item.key).localeCompare(String(b.item.key))
      );
      render(out.slice(0, 200), tokens);
    }

    const onInput = debounce(() => search($q.value), 60);

    // ---- Initialize ---------------------------------------------------------
    (async function init() {
      await loadData();
      document.addEventListener('keydown', (e) => {
        if (e.key === '/' && document.activeElement !== $q) {
          e.preventDefault();
          $q.focus();
          $q.select();
        }
      });
      $q.addEventListener('input', onInput);
      // If URL has ?q= prefill.
      if (qs.get("q")) {
        $q.value = qs.get("q");
        search($q.value);
      } else {
        render([], []);
      }
    })();
  </script>
</body>

</html>